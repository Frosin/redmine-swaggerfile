// Package redmine provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package redmine

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// CustomField defines model for Custom_field.
type CustomField struct {
	Description *string `json:"description,omitempty"`
	Id          int     `json:"id"`
	Multiple    *bool   `json:"multiple,omitempty"`
	Name        *string `json:"name,omitempty"`
	Value       string  `json:"value"`
}

// ErrorsResponse defines model for Errors_response.
type ErrorsResponse struct {
	Errors *[]string `json:"errors,omitempty"`
}

// IdName defines model for IdName.
type IdName struct {
	Id   int    `json:"id"`
	Name string `json:"name"`
}

// Issue defines model for Issue.
type Issue struct {
	AssignedTo     *IdName    `json:"assigned_to,omitempty"`
	Author         IdName     `json:"author"`
	ClosedOn       *time.Time `json:"closed_on,omitempty"`
	CreatedOn      time.Time  `json:"created_on"`
	Description    string     `json:"description"`
	DoneRatio      float32    `json:"done_ratio"`
	DueDate        *string    `json:"due_date,omitempty"`
	EstimatedHours *float32   `json:"estimated_hours,omitempty"`
	Id             int        `json:"id"`
	IsPrivate      *bool      `json:"is_private,omitempty"`

	// journal
	Journals  *[]Journal `json:"journals,omitempty"`
	Priority  IdName     `json:"priority"`
	Project   IdName     `json:"project"`
	StartDate string     `json:"start_date"`
	Status    IdName     `json:"status"`
	Subject   string     `json:"subject"`
	Tracker   IdName     `json:"tracker"`
	UpdatedOn time.Time  `json:"updated_on"`
}

// IssueCreateUpdateObject defines model for Issue_create_update_object.
type IssueCreateUpdateObject struct {

	// "it will be int value but unassign if value == ''"
	AssignedToId *string `json:"assigned_to_id,omitempty"`
	CategoryId   *int    `json:"category_id,omitempty"`

	// Custom fields
	CustomFields *[]CustomField `json:"custom_fields,omitempty"`
	Description  *string        `json:"description,omitempty"`

	// Number of hours estimated for issue
	EstimatedHours *float32 `json:"estimated_hours,omitempty"`

	// "ID of the Target Versions (previously called "Fixed Version" and still referred to as such in the API)"
	FixedVersionId *int `json:"fixed_version_id,omitempty"`

	// "Use true or false to indicate whether the issue is private or not"
	IsPrivate *bool `json:"is_private,omitempty"`

	// note comment (only in update)
	Notes *string `json:"notes,omitempty"`

	// "ID of the parent issue"
	ParentIssueId *int `json:"parent_issue_id,omitempty"`
	PriorityId    *int `json:"priority_id,omitempty"`
	ProjectId     *int `json:"project_id,omitempty"`

	// issue status id (only in update)
	StatusId  *int    `json:"status_id,omitempty"`
	Subject   *string `json:"subject,omitempty"`
	TrackerId *int    `json:"tracker_id,omitempty"`

	// "Array of user ids to add as watchers (since 2.3.0)"
	WatcherUserIds *[]int `json:"watcher_user_ids,omitempty"`
}

// Journal defines model for Journal.
type Journal struct {
	CreatedOn    time.Time            `json:"created_on"`
	Details      []JournalHistoryItem `json:"details"`
	Id           int                  `json:"id"`
	Notes        string               `json:"notes"`
	PrivateNotes bool                 `json:"private_notes"`
	User         *IdName              `json:"user,omitempty"`
}

// JournalHistoryItem defines model for Journal_history_item.
type JournalHistoryItem struct {
	Name     *string `json:"name,omitempty"`
	NewValue *string `json:"new_value,omitempty"`
	OldValue *string `json:"old_value,omitempty"`
	Property *string `json:"property,omitempty"`
}

// Project defines model for Project.
type Project struct {
	CreatedOn      time.Time `json:"created_on"`
	Description    string    `json:"description"`
	Id             int       `json:"id"`
	Identifier     string    `json:"identifier"`
	InheritMembers *bool     `json:"inherit_members,omitempty"`
	IsPublic       *bool     `json:"is_public,omitempty"`
	Name           string    `json:"name"`
	Status         int       `json:"status"`
	Trackers       *[]IdName `json:"trackers,omitempty"`
	UpdatedOn      time.Time `json:"updated_on"`
}

// ProjectCreateUpdateObject defines model for Project_create_update_object.
type ProjectCreateUpdateObject struct {
	CustomFields    *[]CustomField `json:"custom_fields,omitempty"`
	Description     *string        `json:"description,omitempty"`
	Homepage        *string        `json:"homepage,omitempty"`
	Identifier      *string        `json:"identifier,omitempty"`
	InheritMembers  *bool          `json:"inherit_members,omitempty"`
	IsPublic        *bool          `json:"is_public,omitempty"`
	IssueCategories *[]string      `json:"issue_categories,omitempty"`
	Name            *string        `json:"name,omitempty"`
	ParentId        *float32       `json:"parent_id,omitempty"`
	TrackerIds      *[]int         `json:"tracker_ids,omitempty"`
}

// Tracker defines model for Tracker.
type Tracker struct {
	DefaultStatus *IdName `json:"default_status,omitempty"`
	Description   *string `json:"description,omitempty"`
	Id            *int    `json:"id,omitempty"`
	Name          *string `json:"name,omitempty"`
}

// User defines model for User.
type User struct {
	Admin       bool       `json:"admin"`
	CreatedOn   *time.Time `json:"created_on,omitempty"`
	Firstname   string     `json:"firstname"`
	Groups      *[]IdName  `json:"groups,omitempty"`
	Id          int        `json:"id"`
	LastLoginOn *time.Time `json:"last_login_on,omitempty"`
	Lastname    string     `json:"lastname"`
	Login       string     `json:"login"`
	Mail        string     `json:"mail"`
}

// AssignedToId defines model for assigned_to_id.
type AssignedToId string

// CfX defines model for cf_x.
type CfX string

// CreatedOn defines model for created_on.
type CreatedOn string

// Format defines model for format.
type Format string

// GroupId defines model for group_id.
type GroupId string

// Include defines model for include.
type Include string

// IssueId defines model for issue_id.
type IssueId int

// IssueIds defines model for issue_ids.
type IssueIds string

// Limit defines model for limit.
type Limit int

// Name defines model for name.
type Name string

// Offset defines model for offset.
type Offset int

// ProjectID defines model for projectID.
type ProjectID int

// ProjectId defines model for project_id.
type ProjectId int

// Sort defines model for sort.
type Sort string

// Status defines model for status.
type Status string

// StatusId defines model for status_id.
type StatusId string

// SubprojectId defines model for subproject_id.
type SubprojectId string

// TrackerId defines model for tracker_id.
type TrackerId int

// UpdatedOn defines model for updated_on.
type UpdatedOn string

// UserId defines model for user_id.
type UserId int

// IssuesListParams defines parameters for IssuesList.
type IssuesListParams struct {

	// skip this number of issues in response (optional)
	Offset *Offset `json:"offset,omitempty"`

	// number of issues per page (optional)
	Limit *Limit `json:"limit,omitempty"`

	// column to sort with. Append :desc to invert the order.
	Sort *Sort `json:"sort,omitempty"`

	// get issues from the project with the given id (a numeric value, not a project identifier).
	ProjectId *ProjectID `json:"project_id,omitempty"`

	// get issues from the subproject with the given id. You can use project_id=XXX&subproject_id=!* to get only the issues of a given project and none of its subprojects.
	SubprojectId *SubprojectId `json:"subproject_id,omitempty"`

	// get issues from the tracker with the given id
	TrackerId *TrackerId `json:"tracker_id,omitempty"`

	// get issues with the given status id only. Possible values: open, closed, * to get open and closed issues, status id
	StatusId *StatusId `json:"status_id,omitempty"`

	// get issues which are assigned to the given user id. me can be used instead an ID to fetch all issues from the logged in user (via API key or HTTP auth)
	AssignedToId *AssignedToId `json:"assigned_to_id,omitempty"`

	// get issues with the given value for custom field with an ID of x. (Custom field must have "used as a filter" checked.)
	CfX *CfX `json:"cf_x,omitempty"`

	// fetch associated data (optional). Possible values: trackers, issue_categories, enabled_modules (since 2.6.0).
	// Values should be separated by a comma ",".
	Include   *Include   `json:"include,omitempty"`
	CreatedOn *CreatedOn `json:"created_on,omitempty"`
	UpdatedOn *UpdatedOn `json:"updated_on,omitempty"`
	IssueId   *IssueIds  `json:"issue_id,omitempty"`
}

// CreateIssueJSONBody defines parameters for CreateIssue.
type CreateIssueJSONBody struct {

	// issuedescription
	Issue IssueCreateUpdateObject `json:"issue"`
}

// GetIssueParams defines parameters for GetIssue.
type GetIssueParams struct {

	// fetch associated data (optional). Possible values: trackers, issue_categories, enabled_modules (since 2.6.0).
	// Values should be separated by a comma ",".
	Include *Include `json:"include,omitempty"`
}

// UpdateIssueJSONBody defines parameters for UpdateIssue.
type UpdateIssueJSONBody struct {

	// issuedescription
	Issue IssueCreateUpdateObject `json:"issue"`
}

// AddIssueWatchersJSONBody defines parameters for AddIssueWatchers.
type AddIssueWatchersJSONBody struct {

	// id of the user to add as a watcher
	UserId int `json:"user_id"`
}

// ProjectsListParams defines parameters for ProjectsList.
type ProjectsListParams struct {

	// fetch associated data (optional). Possible values: trackers, issue_categories, enabled_modules (since 2.6.0).
	// Values should be separated by a comma ",".
	Include *Include `json:"include,omitempty"`
}

// CreateProjectJSONBody defines parameters for CreateProject.
type CreateProjectJSONBody struct {
	Project ProjectCreateUpdateObject `json:"project"`
}

// UpdateProjectJSONBody defines parameters for UpdateProject.
type UpdateProjectJSONBody struct {
	Project ProjectCreateUpdateObject `json:"project"`
}

// UsersListParams defines parameters for UsersList.
type UsersListParams struct {
	Status  *Status  `json:"status,omitempty"`
	Name    *Name    `json:"name,omitempty"`
	GroupId *GroupId `json:"group_id,omitempty"`
}

// GetUserParams defines parameters for GetUser.
type GetUserParams struct {

	// fetch associated data (optional). Possible values: trackers, issue_categories, enabled_modules (since 2.6.0).
	// Values should be separated by a comma ",".
	Include *Include `json:"include,omitempty"`
}

// CreateIssueRequestBody defines body for CreateIssue for application/json ContentType.
type CreateIssueJSONRequestBody CreateIssueJSONBody

// UpdateIssueRequestBody defines body for UpdateIssue for application/json ContentType.
type UpdateIssueJSONRequestBody UpdateIssueJSONBody

// AddIssueWatchersRequestBody defines body for AddIssueWatchers for application/json ContentType.
type AddIssueWatchersJSONRequestBody AddIssueWatchersJSONBody

// CreateProjectRequestBody defines body for CreateProject for application/json ContentType.
type CreateProjectJSONRequestBody CreateProjectJSONBody

// UpdateProjectRequestBody defines body for UpdateProject for application/json ContentType.
type UpdateProjectJSONRequestBody UpdateProjectJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(req *http.Request, ctx context.Context) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A callback for modifying requests which are generated before sending over
	// the network.
	RequestEditor RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditor = fn
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// IssuesList request
	IssuesList(ctx context.Context, format Format, params *IssuesListParams) (*http.Response, error)

	// CreateIssue request  with any body
	CreateIssueWithBody(ctx context.Context, format Format, contentType string, body io.Reader) (*http.Response, error)

	CreateIssue(ctx context.Context, format Format, body CreateIssueJSONRequestBody) (*http.Response, error)

	// DeleteIssue request
	DeleteIssue(ctx context.Context, issueId IssueId, format Format) (*http.Response, error)

	// GetIssue request
	GetIssue(ctx context.Context, issueId IssueId, format Format, params *GetIssueParams) (*http.Response, error)

	// UpdateIssue request  with any body
	UpdateIssueWithBody(ctx context.Context, issueId IssueId, format Format, contentType string, body io.Reader) (*http.Response, error)

	UpdateIssue(ctx context.Context, issueId IssueId, format Format, body UpdateIssueJSONRequestBody) (*http.Response, error)

	// AddIssueWatchers request  with any body
	AddIssueWatchersWithBody(ctx context.Context, issueId IssueId, format Format, contentType string, body io.Reader) (*http.Response, error)

	AddIssueWatchers(ctx context.Context, issueId IssueId, format Format, body AddIssueWatchersJSONRequestBody) (*http.Response, error)

	// DeleteIssueWatcher request
	DeleteIssueWatcher(ctx context.Context, issueId IssueId, userId UserId, format Format) (*http.Response, error)

	// ProjectsList request
	ProjectsList(ctx context.Context, format Format, params *ProjectsListParams) (*http.Response, error)

	// CreateProject request  with any body
	CreateProjectWithBody(ctx context.Context, format Format, contentType string, body io.Reader) (*http.Response, error)

	CreateProject(ctx context.Context, format Format, body CreateProjectJSONRequestBody) (*http.Response, error)

	// DeleteProject request
	DeleteProject(ctx context.Context, projectId ProjectId, format Format) (*http.Response, error)

	// GetProject request
	GetProject(ctx context.Context, projectId ProjectId, format Format) (*http.Response, error)

	// UpdateProject request  with any body
	UpdateProjectWithBody(ctx context.Context, projectId ProjectId, format Format, contentType string, body io.Reader) (*http.Response, error)

	UpdateProject(ctx context.Context, projectId ProjectId, format Format, body UpdateProjectJSONRequestBody) (*http.Response, error)

	// TrackersList request
	TrackersList(ctx context.Context, format Format) (*http.Response, error)

	// UsersList request
	UsersList(ctx context.Context, format Format, params *UsersListParams) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, userId UserId, format Format, params *GetUserParams) (*http.Response, error)
}

func (c *Client) IssuesList(ctx context.Context, format Format, params *IssuesListParams) (*http.Response, error) {
	req, err := NewIssuesListRequest(c.Server, format, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIssueWithBody(ctx context.Context, format Format, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateIssueRequestWithBody(c.Server, format, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIssue(ctx context.Context, format Format, body CreateIssueJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateIssueRequest(c.Server, format, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIssue(ctx context.Context, issueId IssueId, format Format) (*http.Response, error) {
	req, err := NewDeleteIssueRequest(c.Server, issueId, format)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetIssue(ctx context.Context, issueId IssueId, format Format, params *GetIssueParams) (*http.Response, error) {
	req, err := NewGetIssueRequest(c.Server, issueId, format, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIssueWithBody(ctx context.Context, issueId IssueId, format Format, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateIssueRequestWithBody(c.Server, issueId, format, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIssue(ctx context.Context, issueId IssueId, format Format, body UpdateIssueJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateIssueRequest(c.Server, issueId, format, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AddIssueWatchersWithBody(ctx context.Context, issueId IssueId, format Format, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAddIssueWatchersRequestWithBody(c.Server, issueId, format, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AddIssueWatchers(ctx context.Context, issueId IssueId, format Format, body AddIssueWatchersJSONRequestBody) (*http.Response, error) {
	req, err := NewAddIssueWatchersRequest(c.Server, issueId, format, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIssueWatcher(ctx context.Context, issueId IssueId, userId UserId, format Format) (*http.Response, error) {
	req, err := NewDeleteIssueWatcherRequest(c.Server, issueId, userId, format)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsList(ctx context.Context, format Format, params *ProjectsListParams) (*http.Response, error) {
	req, err := NewProjectsListRequest(c.Server, format, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectWithBody(ctx context.Context, format Format, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateProjectRequestWithBody(c.Server, format, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProject(ctx context.Context, format Format, body CreateProjectJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateProjectRequest(c.Server, format, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProject(ctx context.Context, projectId ProjectId, format Format) (*http.Response, error) {
	req, err := NewDeleteProjectRequest(c.Server, projectId, format)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetProject(ctx context.Context, projectId ProjectId, format Format) (*http.Response, error) {
	req, err := NewGetProjectRequest(c.Server, projectId, format)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectWithBody(ctx context.Context, projectId ProjectId, format Format, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateProjectRequestWithBody(c.Server, projectId, format, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProject(ctx context.Context, projectId ProjectId, format Format, body UpdateProjectJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateProjectRequest(c.Server, projectId, format, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) TrackersList(ctx context.Context, format Format) (*http.Response, error) {
	req, err := NewTrackersListRequest(c.Server, format)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UsersList(ctx context.Context, format Format, params *UsersListParams) (*http.Response, error) {
	req, err := NewUsersListRequest(c.Server, format, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, userId UserId, format Format, params *GetUserParams) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, userId, format, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

// NewIssuesListRequest generates requests for IssuesList
func NewIssuesListRequest(server string, format Format, params *IssuesListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "format", format)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/issues.%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "offset", *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "sort", *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ProjectId != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "project_id", *params.ProjectId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SubprojectId != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "subproject_id", *params.SubprojectId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TrackerId != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "tracker_id", *params.TrackerId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StatusId != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "status_id", *params.StatusId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AssignedToId != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "assigned_to_id", *params.AssignedToId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CfX != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "cf_x", *params.CfX); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CreatedOn != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "created_on", *params.CreatedOn); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UpdatedOn != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "updated_on", *params.UpdatedOn); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IssueId != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "issue_id", *params.IssueId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateIssueRequest calls the generic CreateIssue builder with application/json body
func NewCreateIssueRequest(server string, format Format, body CreateIssueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIssueRequestWithBody(server, format, "application/json", bodyReader)
}

// NewCreateIssueRequestWithBody generates requests for CreateIssue with any type of body
func NewCreateIssueRequestWithBody(server string, format Format, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "format", format)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/issues.%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDeleteIssueRequest generates requests for DeleteIssue
func NewDeleteIssueRequest(server string, issueId IssueId, format Format) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "issue_id", issueId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "format", format)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/issues/%s.%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIssueRequest generates requests for GetIssue
func NewGetIssueRequest(server string, issueId IssueId, format Format, params *GetIssueParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "issue_id", issueId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "format", format)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/issues/%s.%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateIssueRequest calls the generic UpdateIssue builder with application/json body
func NewUpdateIssueRequest(server string, issueId IssueId, format Format, body UpdateIssueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateIssueRequestWithBody(server, issueId, format, "application/json", bodyReader)
}

// NewUpdateIssueRequestWithBody generates requests for UpdateIssue with any type of body
func NewUpdateIssueRequestWithBody(server string, issueId IssueId, format Format, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "issue_id", issueId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "format", format)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/issues/%s.%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAddIssueWatchersRequest calls the generic AddIssueWatchers builder with application/json body
func NewAddIssueWatchersRequest(server string, issueId IssueId, format Format, body AddIssueWatchersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddIssueWatchersRequestWithBody(server, issueId, format, "application/json", bodyReader)
}

// NewAddIssueWatchersRequestWithBody generates requests for AddIssueWatchers with any type of body
func NewAddIssueWatchersRequestWithBody(server string, issueId IssueId, format Format, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "issue_id", issueId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "format", format)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/issues/%s/watchers.%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDeleteIssueWatcherRequest generates requests for DeleteIssueWatcher
func NewDeleteIssueWatcherRequest(server string, issueId IssueId, userId UserId, format Format) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "issue_id", issueId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "user_id", userId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "format", format)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/issues/%s/watchers/%s.%s", pathParam0, pathParam1, pathParam2)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectsListRequest generates requests for ProjectsList
func NewProjectsListRequest(server string, format Format, params *ProjectsListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "format", format)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/projects.%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectRequest calls the generic CreateProject builder with application/json body
func NewCreateProjectRequest(server string, format Format, body CreateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectRequestWithBody(server, format, "application/json", bodyReader)
}

// NewCreateProjectRequestWithBody generates requests for CreateProject with any type of body
func NewCreateProjectRequestWithBody(server string, format Format, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "format", format)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/projects.%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDeleteProjectRequest generates requests for DeleteProject
func NewDeleteProjectRequest(server string, projectId ProjectId, format Format) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project_id", projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "format", format)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/projects/%s.%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectRequest generates requests for GetProject
func NewGetProjectRequest(server string, projectId ProjectId, format Format) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project_id", projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "format", format)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/projects/%s.%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectRequest calls the generic UpdateProject builder with application/json body
func NewUpdateProjectRequest(server string, projectId ProjectId, format Format, body UpdateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectRequestWithBody(server, projectId, format, "application/json", bodyReader)
}

// NewUpdateProjectRequestWithBody generates requests for UpdateProject with any type of body
func NewUpdateProjectRequestWithBody(server string, projectId ProjectId, format Format, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project_id", projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "format", format)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/projects/%s.%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewTrackersListRequest generates requests for TrackersList
func NewTrackersListRequest(server string, format Format) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "format", format)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/trackers.%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersListRequest generates requests for UsersList
func NewUsersListRequest(server string, format Format, params *UsersListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "format", format)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/users.%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Status != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "status", *params.Status); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "name", *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GroupId != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "group_id", *params.GroupId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, userId UserId, format Format, params *GetUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "user_id", userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "format", format)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/users/%s.%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		if !strings.HasSuffix(baseURL, "/") {
			baseURL += "/"
		}
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

type issuesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Issues     []Issue `json:"issues"`
		Limit      int     `json:"limit"`
		Offset     int     `json:"offset"`
		TotalCount int     `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r issuesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r issuesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createIssueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Issue Issue `json:"issue"`
	}
	JSON422 *ErrorsResponse
}

// Status returns HTTPResponse.Status
func (r createIssueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createIssueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type deleteIssueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r deleteIssueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r deleteIssueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getIssueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Issue Issue `json:"issue"`
	}
}

// Status returns HTTPResponse.Status
func (r getIssueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getIssueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type updateIssueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *ErrorsResponse
}

// Status returns HTTPResponse.Status
func (r updateIssueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r updateIssueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type addIssueWatchersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r addIssueWatchersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r addIssueWatchersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type deleteIssueWatcherResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r deleteIssueWatcherResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r deleteIssueWatcherResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type projectsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Limit      int       `json:"limit"`
		Offset     int       `json:"offset"`
		Projects   []Project `json:"projects"`
		TotalCount *int      `json:"total_count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r projectsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r projectsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Project Project `json:"project"`
	}
}

// Status returns HTTPResponse.Status
func (r createProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type deleteProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r deleteProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r deleteProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Project Project `json:"project"`
	}
}

// Status returns HTTPResponse.Status
func (r getProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type updateProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r updateProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r updateProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type trackersListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Trackers []Tracker `json:"trackers"`
	}
}

// Status returns HTTPResponse.Status
func (r trackersListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r trackersListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type usersListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Limit      int    `json:"limit"`
		Offset     int    `json:"offset"`
		TotalCount *int   `json:"total_count,omitempty"`
		Users      []User `json:"users"`
	}
}

// Status returns HTTPResponse.Status
func (r usersListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r usersListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		User User `json:"user"`
	}
}

// Status returns HTTPResponse.Status
func (r getUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// IssuesListWithResponse request returning *IssuesListResponse
func (c *ClientWithResponses) IssuesListWithResponse(ctx context.Context, format Format, params *IssuesListParams) (*issuesListResponse, error) {
	rsp, err := c.IssuesList(ctx, format, params)
	if err != nil {
		return nil, err
	}
	return ParseIssuesListResponse(rsp)
}

// CreateIssueWithBodyWithResponse request with arbitrary body returning *CreateIssueResponse
func (c *ClientWithResponses) CreateIssueWithBodyWithResponse(ctx context.Context, format Format, contentType string, body io.Reader) (*createIssueResponse, error) {
	rsp, err := c.CreateIssueWithBody(ctx, format, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateIssueResponse(rsp)
}

func (c *ClientWithResponses) CreateIssueWithResponse(ctx context.Context, format Format, body CreateIssueJSONRequestBody) (*createIssueResponse, error) {
	rsp, err := c.CreateIssue(ctx, format, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateIssueResponse(rsp)
}

// DeleteIssueWithResponse request returning *DeleteIssueResponse
func (c *ClientWithResponses) DeleteIssueWithResponse(ctx context.Context, issueId IssueId, format Format) (*deleteIssueResponse, error) {
	rsp, err := c.DeleteIssue(ctx, issueId, format)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIssueResponse(rsp)
}

// GetIssueWithResponse request returning *GetIssueResponse
func (c *ClientWithResponses) GetIssueWithResponse(ctx context.Context, issueId IssueId, format Format, params *GetIssueParams) (*getIssueResponse, error) {
	rsp, err := c.GetIssue(ctx, issueId, format, params)
	if err != nil {
		return nil, err
	}
	return ParseGetIssueResponse(rsp)
}

// UpdateIssueWithBodyWithResponse request with arbitrary body returning *UpdateIssueResponse
func (c *ClientWithResponses) UpdateIssueWithBodyWithResponse(ctx context.Context, issueId IssueId, format Format, contentType string, body io.Reader) (*updateIssueResponse, error) {
	rsp, err := c.UpdateIssueWithBody(ctx, issueId, format, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIssueResponse(rsp)
}

func (c *ClientWithResponses) UpdateIssueWithResponse(ctx context.Context, issueId IssueId, format Format, body UpdateIssueJSONRequestBody) (*updateIssueResponse, error) {
	rsp, err := c.UpdateIssue(ctx, issueId, format, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIssueResponse(rsp)
}

// AddIssueWatchersWithBodyWithResponse request with arbitrary body returning *AddIssueWatchersResponse
func (c *ClientWithResponses) AddIssueWatchersWithBodyWithResponse(ctx context.Context, issueId IssueId, format Format, contentType string, body io.Reader) (*addIssueWatchersResponse, error) {
	rsp, err := c.AddIssueWatchersWithBody(ctx, issueId, format, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAddIssueWatchersResponse(rsp)
}

func (c *ClientWithResponses) AddIssueWatchersWithResponse(ctx context.Context, issueId IssueId, format Format, body AddIssueWatchersJSONRequestBody) (*addIssueWatchersResponse, error) {
	rsp, err := c.AddIssueWatchers(ctx, issueId, format, body)
	if err != nil {
		return nil, err
	}
	return ParseAddIssueWatchersResponse(rsp)
}

// DeleteIssueWatcherWithResponse request returning *DeleteIssueWatcherResponse
func (c *ClientWithResponses) DeleteIssueWatcherWithResponse(ctx context.Context, issueId IssueId, userId UserId, format Format) (*deleteIssueWatcherResponse, error) {
	rsp, err := c.DeleteIssueWatcher(ctx, issueId, userId, format)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIssueWatcherResponse(rsp)
}

// ProjectsListWithResponse request returning *ProjectsListResponse
func (c *ClientWithResponses) ProjectsListWithResponse(ctx context.Context, format Format, params *ProjectsListParams) (*projectsListResponse, error) {
	rsp, err := c.ProjectsList(ctx, format, params)
	if err != nil {
		return nil, err
	}
	return ParseProjectsListResponse(rsp)
}

// CreateProjectWithBodyWithResponse request with arbitrary body returning *CreateProjectResponse
func (c *ClientWithResponses) CreateProjectWithBodyWithResponse(ctx context.Context, format Format, contentType string, body io.Reader) (*createProjectResponse, error) {
	rsp, err := c.CreateProjectWithBody(ctx, format, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectWithResponse(ctx context.Context, format Format, body CreateProjectJSONRequestBody) (*createProjectResponse, error) {
	rsp, err := c.CreateProject(ctx, format, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectResponse(rsp)
}

// DeleteProjectWithResponse request returning *DeleteProjectResponse
func (c *ClientWithResponses) DeleteProjectWithResponse(ctx context.Context, projectId ProjectId, format Format) (*deleteProjectResponse, error) {
	rsp, err := c.DeleteProject(ctx, projectId, format)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectResponse(rsp)
}

// GetProjectWithResponse request returning *GetProjectResponse
func (c *ClientWithResponses) GetProjectWithResponse(ctx context.Context, projectId ProjectId, format Format) (*getProjectResponse, error) {
	rsp, err := c.GetProject(ctx, projectId, format)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectResponse(rsp)
}

// UpdateProjectWithBodyWithResponse request with arbitrary body returning *UpdateProjectResponse
func (c *ClientWithResponses) UpdateProjectWithBodyWithResponse(ctx context.Context, projectId ProjectId, format Format, contentType string, body io.Reader) (*updateProjectResponse, error) {
	rsp, err := c.UpdateProjectWithBody(ctx, projectId, format, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectWithResponse(ctx context.Context, projectId ProjectId, format Format, body UpdateProjectJSONRequestBody) (*updateProjectResponse, error) {
	rsp, err := c.UpdateProject(ctx, projectId, format, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectResponse(rsp)
}

// TrackersListWithResponse request returning *TrackersListResponse
func (c *ClientWithResponses) TrackersListWithResponse(ctx context.Context, format Format) (*trackersListResponse, error) {
	rsp, err := c.TrackersList(ctx, format)
	if err != nil {
		return nil, err
	}
	return ParseTrackersListResponse(rsp)
}

// UsersListWithResponse request returning *UsersListResponse
func (c *ClientWithResponses) UsersListWithResponse(ctx context.Context, format Format, params *UsersListParams) (*usersListResponse, error) {
	rsp, err := c.UsersList(ctx, format, params)
	if err != nil {
		return nil, err
	}
	return ParseUsersListResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, userId UserId, format Format, params *GetUserParams) (*getUserResponse, error) {
	rsp, err := c.GetUser(ctx, userId, format, params)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// ParseIssuesListResponse parses an HTTP response from a IssuesListWithResponse call
func ParseIssuesListResponse(rsp *http.Response) (*issuesListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &issuesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Issues     []Issue `json:"issues"`
			Limit      int     `json:"limit"`
			Offset     int     `json:"offset"`
			TotalCount int     `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateIssueResponse parses an HTTP response from a CreateIssueWithResponse call
func ParseCreateIssueResponse(rsp *http.Response) (*createIssueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createIssueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Issue Issue `json:"issue"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteIssueResponse parses an HTTP response from a DeleteIssueWithResponse call
func ParseDeleteIssueResponse(rsp *http.Response) (*deleteIssueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &deleteIssueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetIssueResponse parses an HTTP response from a GetIssueWithResponse call
func ParseGetIssueResponse(rsp *http.Response) (*getIssueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getIssueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Issue Issue `json:"issue"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateIssueResponse parses an HTTP response from a UpdateIssueWithResponse call
func ParseUpdateIssueResponse(rsp *http.Response) (*updateIssueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &updateIssueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseAddIssueWatchersResponse parses an HTTP response from a AddIssueWatchersWithResponse call
func ParseAddIssueWatchersResponse(rsp *http.Response) (*addIssueWatchersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &addIssueWatchersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseDeleteIssueWatcherResponse parses an HTTP response from a DeleteIssueWatcherWithResponse call
func ParseDeleteIssueWatcherResponse(rsp *http.Response) (*deleteIssueWatcherResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &deleteIssueWatcherResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseProjectsListResponse parses an HTTP response from a ProjectsListWithResponse call
func ParseProjectsListResponse(rsp *http.Response) (*projectsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &projectsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Limit      int       `json:"limit"`
			Offset     int       `json:"offset"`
			Projects   []Project `json:"projects"`
			TotalCount *int      `json:"total_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateProjectResponse parses an HTTP response from a CreateProjectWithResponse call
func ParseCreateProjectResponse(rsp *http.Response) (*createProjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Project Project `json:"project"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteProjectResponse parses an HTTP response from a DeleteProjectWithResponse call
func ParseDeleteProjectResponse(rsp *http.Response) (*deleteProjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &deleteProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetProjectResponse parses an HTTP response from a GetProjectWithResponse call
func ParseGetProjectResponse(rsp *http.Response) (*getProjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Project Project `json:"project"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateProjectResponse parses an HTTP response from a UpdateProjectWithResponse call
func ParseUpdateProjectResponse(rsp *http.Response) (*updateProjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &updateProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseTrackersListResponse parses an HTTP response from a TrackersListWithResponse call
func ParseTrackersListResponse(rsp *http.Response) (*trackersListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &trackersListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Trackers []Tracker `json:"trackers"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUsersListResponse parses an HTTP response from a UsersListWithResponse call
func ParseUsersListResponse(rsp *http.Response) (*usersListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &usersListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Limit      int    `json:"limit"`
			Offset     int    `json:"offset"`
			TotalCount *int   `json:"total_count,omitempty"`
			Users      []User `json:"users"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*getUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			User User `json:"user"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

